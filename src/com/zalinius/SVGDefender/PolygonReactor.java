package com.zalinius.SVGDefender;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.event.MouseEvent;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.zalinius.architecture.Graphical;
import com.zalinius.architecture.Locatable;
import com.zalinius.architecture.Logical;
import com.zalinius.architecture.input.Clickable;
import com.zalinius.physics.Point;
import com.zalinius.physics.Vector;

public class PolygonReactor implements Logical, Graphical, Clickable {

	private List<Vertex> vertices;
	private Vertex center;
	private boolean dragging;
	private Locatable mouse;

	public PolygonReactor(Locatable mouse) {
		this(mouse, PolygonFactory.simplePolygon(7));
	}
	public PolygonReactor(Locatable mouse, List<Point> points) {
		vertices = new ArrayList<Vertex>();
		for (Iterator<Point> it = points.iterator(); it.hasNext();) {
			Point point = it.next();
			vertices.add(new Vertex(point));
		}
		center = new Vertex(Point.center(points), 10);
		
		this.mouse = mouse;
	}
	
	
	




	public void update(double delta) {
		//Calculate all forces
		List<Vector> forces = new ArrayList<Vector>();
		for (int i = 0; i < vertices.size(); i++) {
			forces.add(new Vector());
		}
		Vector centerForce = new Vector();

		for (int i = 0; i < vertices.size(); i++) {
			Vertex vertex1 = vertices.get(i);
			Vertex vertex2 = vertices.get(Math.floorMod(i + 1, vertices.size()));

			Vector forceOn1 = elasticForce(vertex1.position(), vertex2.position(), 10, segmentWidth());
			Vector forceOn2 = forceOn1.scale(-1);

			forces.set(i, forces.get(i).add(forceOn1));
			forces.set(Math.floorMod(i + 1, vertices.size()), forces.get(Math.floorMod(i + 1, vertices.size())).add(forceOn2));




			Vector centerForceOn1 = elasticForce(vertex1.position(), center.position(), 5, polygonRadius(vertices.size(), segmentWidth()));
			Vector forceOf1OnCenter = centerForceOn1.scale(-1);

			forces.set(i, forces.get(i).add(centerForceOn1));
			centerForce = centerForce.add(forceOf1OnCenter);


			//friction
			Vector friction = frictionForce(vertex1.velocity());
			forces.set(i, forces.get(i).add(friction));
		}

		if(dragging) {
			Vector mouseDraggingForce = new Vector(center.position(), mouse.center());
			double maxDraggingForce = 500;
			double magnitude = Math.min(mouseDraggingForce.length(), maxDraggingForce);
			mouseDraggingForce = mouseDraggingForce.normalize().scale(magnitude);
			mouseDraggingForce.scale(mouseDraggingForce.length());
			centerForce = centerForce.add(mouseDraggingForce);
			
		}


		//Apply all forces
		for (int i = 0; i < vertices.size(); ++i) {
			vertices.get(i).update(forces.get(i), delta);
		}
		center.update(centerForce, delta);
	}

	public static Vector frictionForce(Vector velocity) {
		double friction = .5;
		return velocity.scale(-1 * friction);
	}


	/**
	 * The force generated by a spring between two points
	 * @param p1 primary point 
	 * @param p2
	 * @return The elastic force acting on p1, which is the inverse of the one on p2
	 */
	public static Vector elasticForce(Point p1, Point p2, double stiffness, double equilibriumLength) {		
		Vector spring = new Vector(p1, p2);
		Vector direction = spring.normalize();
		double magnitude = stiffness * (spring.length() - equilibriumLength);

		return direction.scale(magnitude);
	}

	public Path2D buildPath() {
		Path2D path = new Path2D.Double();		
		Iterator<Vertex> it = vertices.iterator();
		Vertex first = it.next();
		path.moveTo(first.x(), first.y());
		while (it.hasNext()) {
			Vertex vertex = it.next();
			path.lineTo(vertex.x(), vertex.y());			
		}

		path.closePath();

		return path;
	}

	public void render(Graphics2D g) {

		Path2D path = buildPath();

		g.setStroke(new BasicStroke(10, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
		g.setColor(Color.WHITE);
		g.draw(path);
		g.setColor(Color.RED);
		g.fill(path);

		g.setColor(Color.WHITE);

		g.fill(centeredCircle(center.position(), 10));
	}

	public static Shape centeredCircle(Point center, double radius) {
		double x = center.x - radius;
		double y = center.y - radius;
		double diameter = 2*radius;
		return new Ellipse2D.Double(x, y, diameter, diameter);
	}

	public static double polygonRadius(int sides, double sideLength) {
		return sideLength / (2 * Math.cos(Math.toRadians(90) * ((sides - 2.0) / sides)));
	}

	public static double segmentWidth() {
		return 100;
	}


	public Shape clickArea() {
		return buildPath();
	}


	public int mouseButtonCode() {
		return MouseEvent.BUTTON1;
	}


	public void mouseClicked() {
		//empty
	}


	public void mousePressed() {
		dragging = true;
		// TODO Auto-generated method stub
		
	}


	public void mouseReleased() {
		dragging = false;
		// TODO Auto-generated method stub		
	}

}
