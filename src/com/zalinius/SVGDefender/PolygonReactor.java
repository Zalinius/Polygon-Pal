package com.zalinius.SVGDefender;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.zalinius.architecture.Graphical;
import com.zalinius.architecture.Logical;
import com.zalinius.physics.Point;
import com.zalinius.physics.Vector;

public class PolygonReactor implements Logical, Graphical {

	private List<Vertex> vertices;
	private Vertex center;

	public PolygonReactor() {
		vertices = new ArrayList<Vertex>();
		vertices.add(new Vertex(250, 450));
		vertices.add(new Vertex(350, 450));
		vertices.add(new Vertex(400, 550));
		vertices.add(new Vertex(300, 600));
		vertices.add(new Vertex(200, 550));

		List<Point> positions = new ArrayList<Point>();
		for (Iterator<Vertex> it = vertices.iterator(); it.hasNext();) {
			Vertex vertex = it.next();
			positions.add(vertex.position());
		}
		center = new Vertex(Point.center(positions), 10);
	}


	public void update(double delta) {
		//Calculate all forces
		List<Vector> forces = new ArrayList<Vector>();
		for (int i = 0; i < vertices.size(); i++) {
			forces.add(new Vector());
		}
		Vector centerForce = new Vector();

		for (int i = 0; i < vertices.size(); i++) {
			Vertex vertex1 = vertices.get(i);
			Vertex vertex2 = vertices.get(Math.floorMod(i + 1, vertices.size()));

			Vector forceOn1 = elasticForce(vertex1.position(), vertex2.position(), 20, segmentWidth());
			Vector forceOn2 = forceOn1.scale(-1);

			forces.set(i, forces.get(i).add(forceOn1));
			forces.set(Math.floorMod(i + 1, vertices.size()), forces.get(Math.floorMod(i + 1, vertices.size())).add(forceOn2));




			Vector centerForceOn1 = elasticForce(vertex1.position(), center.position(), 5, polygonRadius(vertices.size(), segmentWidth()));
			Vector forceOf1OnCenter = centerForceOn1.scale(-1);

			forces.set(i, forces.get(i).add(centerForceOn1));
			centerForce = centerForce.add(forceOf1OnCenter);


			//friction
			Vector friction = frictionForce(vertex1.velocity());
			forces.set(i, forces.get(i).add(friction));
		}



		//Apply all forces
		for (int i = 0; i < vertices.size(); ++i) {
			vertices.get(i).update(forces.get(i), delta);
		}
		center.update(centerForce, delta);
	}

	public static Vector frictionForce(Vector velocity) {
		double friction = .5;
		return velocity.scale(-1 * friction);
	}


	/**
	 * The force generated by a spring between two points
	 * @param p1 primary point 
	 * @param p2
	 * @return The elastic force acting on p1, which is the inverse of the one on p2
	 */
	public static Vector elasticForce(Point p1, Point p2, double stiffness, double equilibriumLength) {		
		Vector spring = new Vector(p1, p2);
		Vector direction = spring.normalize();
		double magnitude = stiffness * (spring.length() - equilibriumLength);

		return direction.scale(magnitude);
	}

	public Path2D buildPath() {
		Path2D path = new Path2D.Double();		
		Iterator<Vertex> it = vertices.iterator();
		Vertex first = it.next();
		path.moveTo(first.x(), first.y());
		while (it.hasNext()) {
			Vertex vertex = it.next();
			path.lineTo(vertex.x(), vertex.y());			
		}

		path.closePath();

		return path;
	}

	public void render(Graphics2D g) {

		Path2D path = buildPath();

		g.setStroke(new BasicStroke(10, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
		g.setColor(Color.WHITE);
		g.draw(path);
		g.setColor(Color.RED);
		g.fill(path);

		g.setColor(Color.WHITE);

		g.fill(centeredCircle(center.position(), 10));
	}

	public static Shape centeredCircle(Point center, double radius) {
		double x = center.x - radius;
		double y = center.y - radius;
		double diameter = 2*radius;
		return new Ellipse2D.Double(x, y, diameter, diameter);
	}

	public static double polygonRadius(int sides, double sideLength) {
		return sideLength / (2 * Math.cos(Math.toRadians(90) * ((sides - 2.0) / sides)));
	}

	public double segmentWidth() {
		return 100;
	}

}
